<!DOCTYPE html>
<html lang="en">
Â  <head>
Â  Â  <meta charset="UTF-8" />
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
Â  Â  <title>Social Card Generator</title>
Â  Â  <link href="https://cdn.jsdelivr.net/npm/jameel-noori@1.1.2/jameel-noori.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Baloo+Bhaijaan+2&family=Gulzar&family=Montserrat&family=Noto+Sans+Arabic:wght@100..900&display=swap" rel="stylesheet">
Â  Â  <script src="https://cdn.tailwindcss.com"></script>
Â  Â  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
Â  Â  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
Â  Â  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
Â  Â  Â Â 
Â  </head>
Â  <body class="bg-gray-100">
Â  Â  <div id="root"></div>

Â  Â  <script type="text/babel">
        // Helper function to split text into parts (words and spaces)
        function textToParts(text, defaultColor) {
            if (!text || typeof text !== 'string') return [];
            
            // This regex captures either non-whitespace characters (words) or whitespace (spaces)
            return text.match(/(\S+|\s+)/g) || []
                .map((content, index) => ({
                    id: Date.now() + index, // unique ID for keying/tracking
                    content: content,
                    color: defaultColor,
                }));
        }

        // Helper function to convert parts back to a plain string
        function partsToText(parts) {
            return parts.map(p => p.content).join('');
        }

        // --- Editable Headline Component ---
        function EditableHeadline({ headline, updateHeadline, headlineRefs, activeColor, onColorApply }) {
            const elRef = React.useRef(null);
            
            // Effect to maintain the cursor position/selection after update (complex feature, kept simple here)
            React.useLayoutEffect(() => {
                if (elRef.current && headlineRefs) {
                    headlineRefs.current[headline.id] = elRef.current;
                }
            }, [headline, headlineRefs]);

            // Handler for content changes (updates the text part of the state)
            const handleInput = (e) => {
                const newText = e.target.innerText;
                const currentDefaultColor = headline.parts?.[0]?.color || headline.textColor;
                
                // When text is edited, we re-parse it, preserving the default color.
                // NOTE: This intentionally loses multi-color styling upon full text edit/retype.
                const newParts = textToParts(newText, currentDefaultColor);

                updateHeadline(headline.id, {
                    // Update parts structure
                    parts: newParts.map(p => ({ ...p, color: headline.textColor || '#ffffff' })), 
                });
            };

            // Handler to apply the currently selected color to the selection
            const handleApplyColor = () => {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0 || !activeColor) return;

                const range = selection.getRangeAt(0);
                const container = elRef.current;

                if (!container.contains(range.commonAncestorContainer)) return;

                // Simple implementation: identify the words within the selection and apply color.
                const newParts = [...headline.parts];
                
                newParts.forEach((part, index) => {
                    if (part.content.trim() === '') return; // Skip spaces

                    // Create a temporary range for the part's content node
                    const partNode = container.childNodes[index]; 
                    if (!partNode || partNode.nodeType !== Node.ELEMENT_NODE) return;

                    const wordContentNode = partNode.firstChild;
                    if (!wordContentNode || wordContentNode.nodeType !== Node.TEXT_NODE) return;

                    const partRange = document.createRange();
                    partRange.selectNodeContents(wordContentNode);

                    // Check if the current word's range intersects with the user's selection range
                    if (range.intersectsNode(wordContentNode)) {
                        newParts[index] = { ...part, color: activeColor };
                    }
                });

                updateHeadline(headline.id, { parts: newParts });
                onColorApply(); // Clear active color after application
            };

            const headlineStyle = {
                position: "absolute",
                left: headline.direction === "ltr" ? headline.textPos.x : "auto",
                right: headline.direction === "rtl" ? headline.textPos.x : "auto", 
                top: headline.textPos.y,
                fontSize: headline.fontSize,
                lineHeight: headline.lineHeight,
                fontFamily: headline.fontFamily,
                textShadow: headline.shadow.enabled ? `${headline.shadow.offsetX}px ${headline.shadow.offsetY}px ${headline.shadow.blur}px ${headline.shadow.color}` : "none",
                WebkitTextStroke: headline.stroke.enabled ? `${headline.stroke.width}px ${headline.stroke.color}` : "none",
                whiteSpace: "pre-wrap",
                width: headline.width ? `${headline.width}px` : "80%",
                maxWidth: "100%",
                textAlign: headline.textAlign,
                cursor: 'move', // Cursor remains 'move' for the outer container
                zIndex: 200,
            };

            return (
                <div 
                    ref={elRef}
                    data-headline="true"
                    onMouseDown={e => {
                        // Only allow dragging if the user clicks *outside* the editable content, 
                        // or if they initiate a drag rather than a selection
                        if (e.target === elRef.current || e.target.nodeName === 'SPAN') {
                             if (headline.draggableHeadlines) {
                                e.stopPropagation();
                                headline.startDragText(e, headline.id);
                            }
                        }
                    }}
                    onMouseUp={handleApplyColor} // Try to apply color on mouse up
                    onTouchEnd={handleApplyColor} // Try to apply color on touch end
                    dir={headline.direction}
                    contentEditable={true}
                    suppressContentEditableWarning={true}
                    onInput={handleInput}
                    style={headlineStyle}
                >
                    {headline.parts.map((part, index) => (
                        <span key={part.id} style={{ color: part.color }}>
                            {part.content}
                        </span>
                    ))}
                </div>
            );
        }
        // --- End Editable Headline Component ---
        
Â  Â  Â  function SocialCardGenerator() {
Â  Â  Â  Â  const { useState, useRef, useEffect } = React;
Â  Â  Â  Â  const containerRef = useRef(null);
Â  Â  Â 
        // --- NEW STATE for Word Coloring ---
        const [activeWordColor, setActiveWordColor] = useState('#ff0000');
        // -----------------------------------
        
Â  Â  Â  Â  Â  const [isAuthenticated, setIsAuthenticated] = useState(() => {
Â  try {
Â  Â  const savedAuth = localStorage.getItem('socialCardAuth');
Â  Â  return savedAuth ? JSON.parse(savedAuth) : false;
Â  } catch (e) {
Â  Â  console.error("Failed to load authentication status from localStorage", e);
Â  Â  return false;
Â  }
});
Â  Â  Â  Â  // State variables for collapsing sections
Â  Â  Â  Â  const [isBackgroundCollapsed, setIsBackgroundCollapsed] = useState(false);
Â  Â  Â  Â  const [isPresetsCollapsed, setIsPresetsCollapsed] = useState(false);
Â  Â  Â  Â  const [isImagesCollapsed, setIsImagesCollapsed] = useState(false);
Â  Â  Â  Â  const [isVignetteCollapsed, setIsVignetteCollapsed] = useState(false);
Â  Â  Â  Â  const [isLogoCollapsed, setIsLogoCollapsed] = useState(false);
Â  Â  Â  Â  const [isCanvasCollapsed, setIsCanvasCollapsed] = useState(false);
Â  Â  Â  Â  const [isFileNameCollapsed, setIsFileNameCollapsed] = useState(false);
Â  Â  Â  Â  const [vignette, setVignette] = useState({ show: false, x: 0, y: 0, scale: 1 });
Â  Â  Â  Â Â 
Â  Â  Â  Â  const [DEFAULT_PRESETS, setDEFAULT_PRESETS] = useState({});
Â  Â  Â  Â  const [presets, setPresets] = React.useState({});
Â  Â  Â  Â  const [currentPresetName, setCurrentPresetName] = useState(null);

Â  Â  Â  Â  // Load presets from JSON file
Â  Â  Â  Â  useEffect(() => {
Â  Â  Â  Â  Â  fetch('presets.json')
Â  Â  Â  Â  Â  Â  .then(response => response.json())
Â  Â  Â  Â  Â  Â  .then(data => {
Â  Â  Â  Â  Â  Â  Â  setDEFAULT_PRESETS(data);
Â  Â  Â  Â  Â  Â  Â  const saved = localStorage.getItem("userPresets");
Â  Â  Â  Â  Â  Â  Â  setPresets({ ...data, ...(saved ? JSON.parse(saved) : {}) });
Â  Â  Â  Â  Â  Â  })
Â  Â  Â  Â  Â  Â  .catch(err => {
Â  Â  Â  Â  Â  Â  Â  console.error("Failed to load presets.json", err);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }, []);


Â  Â  Â  Â  function loadPreset(name) {
Â  Â  Â  Â  Â  const preset = presets[name];
Â  Â  Â  Â  Â  if (!preset) {
Â  Â  Â  Â  Â  Â  alert("Preset not found");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }

            // PRESET LOADING LOGIC UPDATED FOR NEW DATA STRUCTURE
Â  Â  Â  Â  Â  setHeadlines(preset.headlines.map(h => ({
                ...h,
                // If the preset has the old 'text' property, convert it. Otherwise, use 'parts'.
                parts: h.parts || textToParts(h.text, h.textColor || '#ffffff'),
                text: undefined, // Remove old property
            })) || []);
Â  Â  Â  Â  Â  setImages(preset.images.map(img => ({
Â  Â  Â  Â  Â  Â  Â  ...img,
Â  Â  Â  Â  Â  Â  Â  scale: img.scale !== undefined ? img.scale : 1,
Â  Â  Â  Â  Â  Â  Â  fitMode: img.fitMode || { top: false, right: false, bottom: false, left: false },
Â  Â  Â  Â  Â  Â  Â  stretchEnabled: img.stretchEnabled || false,
Â  Â  Â  Â  Â  })) || []);
Â  Â  Â  Â  Â  if (preset.width) setWidth(preset.width);
Â  Â  Â  Â  Â  if (preset.height) setHeight(preset.height);
Â  Â  Â  Â  Â  if (preset.logo) setLogo(preset.logo);
Â  Â  Â  Â  Â  if (preset.fileName) setFileName(preset.fileName);
Â  Â  Â  Â  Â  if (preset.vignette !== undefined) setVignette(preset.vignette);
Â  Â  Â  Â  Â  if (preset.globalBorderColor) setGlobalBorderColor(preset.globalBorderColor);
Â  Â  Â  Â  Â  if (preset.globalBorderSize !== undefined) setGlobalBorderSize(preset.globalBorderSize);
Â  Â  Â  Â  Â  if (preset.background) {
Â  Â  Â  Â  Â  Â  setBackground(preset.background);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (preset.draggableHeadlines !== undefined) {
Â  Â  Â  Â  Â  Â  Â  setDraggableHeadlines(preset.draggableHeadlines);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  setDraggableHeadlines(true);
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  setCurrentPresetName(name);

Â  Â  Â  Â  Â  alert(`${name} preset loaded!`);
Â  Â  Â  Â  }

Â  Â  Â  Â  function savePreset(name) {
Â  Â  Â  Â  Â  if (!name) {
Â  Â  Â  Â  Â  Â  alert("Please enter a preset name");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  const newPreset = {
            // Save headlines using the new 'parts' structure
Â  Â  Â  Â  Â  Â  headlines: headlines.map(h => ({
                ...h,
                text: partsToText(h.parts), // Keep 'text' string for backward compatibility
            })),Â 
Â  Â  Â  Â  Â  Â  images: images.map(img => ({
Â  Â  Â  Â  Â  Â  Â  Â  id: img.id,
Â  Â  Â  Â  Â  Â  Â  Â  src: img.src,
Â  Â  Â  Â  Â  Â  Â  Â  x: img.x,
Â  Â  Â  Â  Â  Â  Â  Â  y: img.y,
Â  Â  Â  Â  Â  Â  Â  Â  scale: img.scale,
Â  Â  Â  Â  Â  Â  Â  Â  zIndex: img.zIndex,
Â  Â  Â  Â  Â  Â  Â  Â  borderEnabled: img.borderEnabled,
Â  Â  Â  Â  Â  Â  Â  Â  stretchEnabled: img.stretchEnabled,
Â  Â  Â  Â  Â  Â  Â  Â  fitMode: img.fitMode,
Â  Â  Â  Â  Â  Â  })),
Â  Â  Â  Â  Â  Â  width, height, logo, fileName, vignette,
Â  Â  Â  Â  Â  Â  globalBorderColor, globalBorderSize, background,
Â  Â  Â  Â  Â  Â  draggableHeadlines
Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  const updatedPresets = { ...presets, [name]: newPreset };
Â  Â  Â  Â  Â  setPresets(updatedPresets);
Â  Â  Â  Â  Â  localStorage.setItem("userPresets", JSON.stringify(updatedPresets));

Â  Â  Â  Â  Â  alert(`Preset "${name}" saved!`);
Â  Â  Â  Â  }

Â  Â  Â  Â  function deletePreset(name) {
Â  Â  Â  Â  Â  if (!name) {
Â  Â  Â  Â  Â  Â  alert("Please select a preset to delete");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (DEFAULT_PRESETS[name]) {
Â  Â  Â  Â  Â  Â  alert("Default presets cannot be deleted");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  const updatedPresets = { ...presets };
Â  Â  Â  Â  Â  delete updatedPresets[name];
Â  Â  Â  Â  Â  setPresets(updatedPresets);
Â  Â  Â  Â  Â  localStorage.setItem("userPresets", JSON.stringify(updatedPresets));

Â  Â  Â  Â  Â  alert(`Preset "${name}" deleted!`);
Â  Â  Â  Â  }

Â  Â  Â  Â  function resetPresets() {
Â  Â  Â  Â  Â  if (!window.confirm("This will delete all your saved presets and restore only the defaults. Continue?")) {
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  setPresets(DEFAULT_PRESETS);
Â  Â  Â  Â  Â  localStorage.removeItem("userPresets");
Â  Â  Â  Â  Â  alert("Presets reset to default!");
Â  Â  Â  Â  }

Â  Â  Â  Â  function exportPresets() {
            // Ensure export uses the latest structure
Â  Â  Â  Â  Â  const exportablePresets = JSON.parse(JSON.stringify(presets));
            Object.keys(exportablePresets).forEach(key => {
                exportablePresets[key].headlines = exportablePresets[key].headlines.map(h => ({
                    ...h,
                    text: h.text || partsToText(h.parts),
                }));
            });
Â  Â  Â  Â  Â  const json = JSON.stringify(exportablePresets, null, 2);
Â  Â  Â  Â  Â  navigator.clipboard.writeText(json)
Â  Â  Â  Â  Â  Â  .then(() => alert("All presets copied to clipboard!"))
Â  Â  Â  Â  Â  Â  .catch(err => console.error("Clipboard copy failed", err));
Â  Â  Â  Â  }

Â  Â  Â  Â  function importPresets() {
Â  Â  Â  Â  Â  const json = prompt("Paste presets JSON here:");
Â  Â  Â  Â  Â  if (!json) return;
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const parsed = JSON.parse(json);
Â  Â  Â  Â  Â  Â  if (typeof parsed !== "object") throw new Error("Invalid format");

                // Ensure imported headlines get the new 'parts' structure
                Object.keys(parsed).forEach(key => {
                    if (parsed[key].headlines) {
                        parsed[key].headlines = parsed[key].headlines.map(h => ({
                            ...h,
                            parts: h.parts || textToParts(h.text, h.textColor || '#ffffff'),
                            text: undefined,
                        }));
                    }
                });

Â  Â  Â  Â  Â  Â  const updatedPresets = { ...DEFAULT_PRESETS, ...parsed };
Â  Â  Â  Â  Â  Â  setPresets(updatedPresets);
Â  Â  Â  Â  Â  Â  localStorage.setItem("userPresets", JSON.stringify(parsed));

Â  Â  Â  Â  Â  Â  alert("Presets imported successfully!");
Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  alert("Invalid presets JSON");
Â  Â  Â  Â  Â  Â  console.error("Import failed:", e);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  const [globalBorderColor, setGlobalBorderColor] = useState("#ffffff");
Â  Â  Â  Â  const [globalBorderSize, setGlobalBorderSize] = useState(4);
Â  Â  Â  Â  const [images, setImages] = useState([]);
Â  Â  Â  Â  const [activeImageId, setActiveImageId] = useState(null);
Â  Â  Â  Â  const [width, setWidth] = useState(1080);
Â  Â  Â  Â  const [height, setHeight] = useState(1080);
Â  Â  Â  Â  const [logo, setLogo] = useState({ show: true, position: "top-right" });
Â  Â  Â  Â  const [fileName, setFileName] = useState("social-card");
Â  Â  Â  Â  const [background, setBackground] = useState({
Â  Â  Â  Â  Â  type: 'solid',
Â  Â  Â  Â  Â  color: '#000000',
Â  Â  Â  Â  Â  gradient: {
Â  Â  Â  Â  Â  Â  color1: '#ffffff',
Â  Â  Â  Â  Â  Â  color2: '#000000',
Â  Â  Â  Â  Â  Â  direction: 'to bottom right'
Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  imageSrc: 'bg.png'
Â  Â  Â  Â  });
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  const DEFAULT_HEADLINE_TEXT = "Headline here";
        const DEFAULT_HEADLINE_COLOR = "#ffffff";

Â  Â  Â  Â  const [headlines, setHeadlines] = useState([{
Â  Â  Â  Â  Â  id: Date.now(),
Â  Â  Â  Â  Â  parts: textToParts(DEFAULT_HEADLINE_TEXT, DEFAULT_HEADLINE_COLOR), // New data structure
            text: DEFAULT_HEADLINE_TEXT, // Keep a temporary text version for controls/compatibility
Â  Â  Â  Â  Â  fontSize: 90,
Â  Â  Â  Â  Â  lineHeight: 1.2,
Â  Â  Â  Â  Â  fontFamily: "JameelNooriNastaliq",
Â  Â  Â  Â  Â  textColor: DEFAULT_HEADLINE_COLOR,
Â  Â  Â  Â  Â  textPos: { x: 100, y: 200 },
Â  Â  Â  Â  Â  direction: "rtl",
Â  Â  Â  Â  Â  textAlign: "right",
Â  Â  Â  Â  Â  sidelineOffset: 0,
Â  Â  Â  Â  Â  shadow: { enabled: true, offsetX: 2, offsetY: 2, blur: 6, color: "rgba(0,0,0,0.6)" },
Â  Â  Â  Â  Â  stroke: { enabled: false, width: 1, color: "#000000" },
Â  Â  Â  Â  Â  // when creating or adding initial headlines
Â  Â  Â  Â  Â  Â  sideline: { show: true, width: 30, gap: 60, height: null, autoHeight: true, color: "#ff0000", opacity: 1 },
Â  Â  Â  Â  Â  sidelineOffset: 0,
Â  Â  Â  Â  Â  isCollapsed: false,
Â  Â  Â  Â  Â  width: 800,
Â  Â  Â  Â  }]);
Â  Â  Â  Â  const [expandedHeadlineId, setExpandedHeadlineId] = useState(null);
Â  Â  Â  Â  const headlineRefs = useRef({});
Â  Â  Â  Â  const [draggableHeadlines, setDraggableHeadlines] = useState(true);

Â  Â  Â  Â  function addHeadline() {
            const defaultTextColor = "#ffffff";
Â  Â  Â  Â  Â  const newHeadline = {
Â  Â  Â  Â  Â  Â  id: Date.now(),
Â  Â  Â  Â  Â  Â  parts: textToParts("New Headline", defaultTextColor), // Use new parts structure
Â  Â  Â  Â  Â  Â  text: "New Headline", // Temp string for controls/compatibility
Â  Â  Â  Â  Â  Â  fontSize: 60,
Â  Â  Â  Â  Â  Â  lineHeight: 1.2,
Â  Â  Â  Â  Â  Â  fontFamily: "JameelNooriNastaliq",
Â  Â  Â  Â  Â  Â  textColor: defaultTextColor,
Â  Â  Â  Â  Â  Â  textPos: { x: 100, y: 300 },
Â  Â  Â  Â  Â  Â  direction: "rtl",
Â  Â  Â  Â  Â  Â  textAlign: "right",
Â  Â  Â  Â  Â  Â  sidelineOffset: 0,
Â  Â  Â  Â  Â  Â  shadow: { enabled: true, offsetX: 2, offsetY: 2, blur: 6, color: "rgba(0,0,0,0.6)" },
Â  Â  Â  Â  Â  Â  stroke: { enabled: false, width: 1, color: "#000000" },
Â  Â  Â  Â  Â  Â  // when creating or adding initial headlines
sideline: { show: true, width: 30, gap: 60, height: null, autoHeight: true, color: "#ff0000", opacity: 1 },
Â  Â  Â  Â  Â  Â  Â sidelineOffset: 0,
Â  Â  Â  Â  Â  Â  isCollapsed: false,
Â  Â  Â  Â  Â  Â  width: 800,
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  setHeadlines([...headlines, newHeadline]);
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateHeadline(id, updatedProps) {
            // Special handling: if `text` is updated (from textarea/load), re-parse it into `parts`.
            if (updatedProps.text !== undefined) {
                const existingHeadline = headlines.find(h => h.id === id);
                const defaultColor = existingHeadline ? existingHeadline.textColor : '#ffffff';
                
                updatedProps.parts = textToParts(updatedProps.text, defaultColor);
                
                // When updating text via the main text area, reset individual word colors to the main text color.
                updatedProps.parts = updatedProps.parts.map(p => ({
                    ...p,
                    color: updatedProps.textColor || defaultColor
                }));
            }
            
Â  Â  Â  Â  Â  setHeadlines(current => current.map(h => {
                if (h.id === id) {
                    // Update text property from parts if it was a direct parts update (like color change)
                    const updatedH = { ...h, ...updatedProps };
                    updatedH.text = partsToText(updatedH.parts || h.parts);
                    return updatedH;
                }
                return h;
            }));
Â  Â  Â  Â  }

Â  Â  Â  Â  function deleteHeadline(id) {
Â  Â  Â  Â  Â  setHeadlines(current => current.filter(h => h.id !== id));
Â  Â  Â  Â  Â  if (expandedHeadlineId === id) {
Â  Â  Â  Â  Â  Â  setExpandedHeadlineId(null);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  Â  useEffect(() => {
Â  try {
Â  Â  localStorage.setItem('socialCardAuth', JSON.stringify(isAuthenticated));
Â  } catch (e) {
Â  Â  console.error("Failed to save authentication status to localStorage", e);
Â  }
}, [isAuthenticated]);
Â  Â  Â  Â  Â Â 

        // Update useEffect to handle the new 'parts' structure from localStorage
Â  Â  Â  Â  useEffect(() => {
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const savedData = localStorage.getItem('socialCardData');
Â  Â  Â  Â  Â  Â  if (savedData) {
Â  Â  Â  Â  Â  Â  Â  const parsedData = JSON.parse(savedData);
Â  Â  Â  Â  Â  Â  Â  if (parsedData.headlines) setHeadlines(parsedData.headlines.map(h => ({
                    ...h,
                    // Convert old 'text' or new 'text' string on load if 'parts' is missing
                    parts: h.parts || textToParts(h.text || h.partsToText(h.parts), h.textColor || '#ffffff'),
                })));
Â  Â  Â  Â  Â  Â  Â  if (parsedData.images) setImages(parsedData.images.map(img => ({
Â  Â  Â  Â  Â  Â  Â  Â  ...img,
Â  Â  Â  Â  Â  Â  Â  Â  fitMode: img.fitMode || { top: false, right: false, bottom: false, left: false },
Â  Â  Â  Â  Â  Â  Â  Â  stretchEnabled: img.stretchEnabled || false,
Â  Â  Â  Â  Â  Â  Â  })));
Â  Â  Â  Â  Â  Â  Â  if (parsedData.width) setWidth(parsedData.width);
Â  Â  Â  Â  Â  Â  Â  if (parsedData.height) setHeight(parsedData.height);
Â  Â  Â  Â  Â  Â  Â  if (parsedData.logo) setLogo(parsedData.logo);
Â  Â  Â  Â  Â  Â  Â  if (parsedData.fileName) setFileName(parsedData.fileName);
Â  Â  Â  Â  Â  Â  Â  if (parsedData.background) setBackground(parsedData.background);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  console.error("Failed to load data from localStorage", e);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, []);

        // Update useEffect to save the correct structure (parts) to localStorage
Â  Â  Â  Â  useEffect(() => {
Â  Â  Â  Â  Â  const dataToSave = {
                // Ensure headlines stored have the simplified structure for saving
                headlines: headlines.map(h => ({
                    ...h,
                    text: partsToText(h.parts), // save text for backward compatibility
                })),
                images, width, height, logo, fileName, background
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  localStorage.setItem('socialCardData', JSON.stringify(dataToSave));
Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  console.error("Failed to save data to localStorage", e);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, [headlines, images, width, height, logo, fileName, background]);

Â  Â  Â  Â  useEffect(() => {
Â  Â  Â  Â  Â  const handleBeforeUnload = (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  e.returnValue = '';
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  window.addEventListener('beforeunload', handleBeforeUnload);

Â  Â  Â  Â  Â  return () => {
Â  Â  Â  Â  Â  Â  window.removeEventListener('beforeunload', handleBeforeUnload);
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  }, []);

Â  Â  Â  Â  useEffect(() => {
Â  headlines.forEach(h => {
Â  Â  const el = headlineRefs.current[h.id];
Â  Â  if (!el) return;

Â  Â  const measured = el.offsetHeight;

Â  Â  // only auto-set if autosizing is enabled (autoHeight true or undefined)
Â  Â  const wantsAuto = h.sideline?.autoHeight !== false; // treat undefined as true

Â  Â  if (wantsAuto) {
Â  Â  Â  // Write measured height only when different (and only if measured is a valid number)
Â  Â  Â  if (typeof measured === "number" && h.sideline?.height !== measured) {
Â  Â  Â  Â  updateHeadline(h.id, {
Â  Â  Â  Â  Â  sideline: { ...h.sideline, height: measured, autoHeight: true }
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  }
Â  });
Â  // note: intentionally not including updateHeadline in deps list because it's stable in your code.
}, [headlines]);

Â  Â  Â  Â  function onImageUpload(e) {
Â  Â  Â  Â  Â  const files = e.target.files;
Â  Â  Â  Â  Â  if (!files) return;
Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  const newImages = Array.from(files).map((file, index) => {
Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  img.src = URL.createObjectURL(file);
Â  Â  Â  Â  Â  Â  return new Promise((resolve) => {
Â  Â  Â  Â  Â  Â  Â  img.onload = () => {
Â  Â  Â  Â  Â  Â  Â  Â  const newImg = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  id: Date.now() + index,
Â  Â  Â  Â  Â  Â  Â  Â  Â  src: img.src,
Â  Â  Â  Â  Â  Â  Â  Â  Â  x: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  y: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  scale: 1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  zIndex: images.length + index,
Â  Â  Â  Â  Â  Â  Â  Â  Â  borderEnabled: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  fitMode: { top: false, right: false, bottom: false, left: false },
Â  Â  Â  Â  Â  Â  Â  Â  Â  originalWidth: img.naturalWidth,
Â  Â  Â  Â  Â  Â  Â  Â  Â  originalHeight: img.naturalHeight,
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  resolve(newImg);
Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Promise.all(newImages).then(resolvedImages => {
Â  Â  Â  Â  Â  Â  setImages([...images, ...resolvedImages]);
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  function onBackgroundUpload(e) {
Â  Â  Â  Â  Â  const file = e.target.files[0];
Â  Â  Â  Â  Â  if (file) {
Â  Â  Â  Â  Â  Â  const reader = new FileReader();
Â  Â  Â  Â  Â  Â  reader.onload = (event) => {
Â  Â  Â  Â  Â  Â  Â  setBackground({
Â  Â  Â  Â  Â  Â  Â  Â  ...background,
Â  Â  Â  Â  Â  Â  Â  Â  type: 'image',
Â  Â  Â  Â  Â  Â  Â  Â  imageSrc: event.target.result
Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  reader.readAsDataURL(file);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function getCoords(e) {
Â  Â  Â  Â  Â  return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
Â  Â  Â  Â  }

Â  Â  Â  Â  function startDragImage(e, id) {
Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  setActiveImageId(id);
Â  Â  Â  Â  Â  const { x: startX, y: startY } = getCoords(e);
Â  Â  Â  Â  Â  const img = images.find(im => im.id === id);
Â  Â  Â  Â  Â  const initX = img.x, initY = img.y;
Â  Â  Â  Â  Â  const maxZ = Math.max(...images.map(im => im.zIndex));
Â  Â  Â  Â  Â  setImages((imgs) => imgs.map(im => im.id === id ? { ...im, zIndex: maxZ + 1 } : im));

Â  Â  Â  Â  Â  function onMove(ev) {
Â  Â  Â  Â  Â  Â  const { x: currentX, y: currentY } = getCoords(ev);
Â  Â  Â  Â  Â  Â  setImages((imgs) => imgs.map(im => im.id === id ? { ...im, x: initX + currentX - startX, y: initY + currentY - startY } : im));
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  function onUp() {
Â  Â  Â  Â  Â  Â  window.removeEventListener("mousemove", onMove);
Â  Â  Â  Â  Â  Â  window.removeEventListener("mouseup", onUp);
Â  Â  Â  Â  Â  Â  window.removeEventListener("touchmove", onMove);
Â  Â  Â  Â  Â  Â  window.removeEventListener("touchend", onUp);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  window.addEventListener("mousemove", onMove);
Â  Â  Â  Â  Â  window.addEventListener("mouseup", onUp);
Â  Â  Â  Â  Â  window.addEventListener("touchmove", onMove);
Â  Â  Â  Â  Â  window.addEventListener("touchend", onUp);
Â  Â  Â  Â  }

Â  Â  Â function startDragText(e, id) {
Â  e.preventDefault();
Â  e.stopPropagation();

Â  const { x: startX, y: startY } = getCoords(e);
Â  const headline = headlines.find(h => h.id === id);
Â  const initPos = { ...headline.textPos };
Â  const isRTL = headline.direction === "rtl";

Â  function onMove(ev) {
Â  Â  const { x: currentX, y: currentY } = getCoords(ev);
Â  Â  const dx = currentX - startX;
Â  Â  const dy = currentY - startY;

Â  Â  updateHeadline(id, {
Â  Â  Â  textPos: {
Â  Â  Â  Â  x: isRTL ? initPos.x - dx : initPos.x + dx, // ğŸ‘ˆ invert movement for RTL
Â  Â  Â  Â  y: initPos.y + dy,
Â  Â  Â  },
Â  Â  });
Â  }

Â  function onUp() {
Â  Â  window.removeEventListener("mousemove", onMove);
Â  Â  window.removeEventListener("mouseup", onUp);
Â  Â  window.removeEventListener("touchmove", onMove);
Â  Â  window.removeEventListener("touchend", onUp);
Â  }

Â  window.addEventListener("mousemove", onMove);
Â  window.addEventListener("mouseup", onUp);
Â  window.addEventListener("touchmove", onMove);
Â  window.addEventListener("touchend", onUp);
}



Â  Â  Â  Â  function startDragVignette(e) {
Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  const { x: startX, y: startY } = getCoords(e);
Â  Â  Â  Â  Â  const initX = vignette.x, initY = vignette.y;
Â  Â  Â  Â  Â  function onMove(ev) {
Â  Â  Â  Â  Â  Â  const { x: currentX, y: currentY } = getCoords(ev);
Â  Â  Â  Â  Â  Â  setVignette(v => ({ ...v, x: initX + currentX - startX, y: initY + currentY - startY }));
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  function onUp() {
Â  Â  Â  Â  Â  Â  window.removeEventListener("mousemove", onMove);
Â  Â  Â  Â  Â  Â  window.removeEventListener("mouseup", onUp);
Â  Â  Â  Â  Â  Â  window.removeEventListener("touchmove", onMove);
Â  Â  Â  Â  Â  Â  window.removeEventListener("touchend", onUp);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  window.addEventListener("mousemove", onMove);
Â  Â  Â  Â  Â  window.addEventListener("mouseup", onUp);
Â  Â  Â  Â  Â  window.addEventListener("touchmove", onMove);
Â  Â  Â  Â  Â  window.addEventListener("touchend", onUp);
Â  Â  Â  Â  }

Â  Â  Â  Â  function exportAsImage() {
Â  Â  Â  Â  Â  if (!containerRef.current) return;

Â  Â  Â  Â  Â  setActiveImageId(null);

Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â setTimeout(() => {
Â  const textOffset = -40; // adjust between -4 to -7 for perfect match
Â  html2canvas(containerRef.current, {
Â  Â  useCORS: true,
Â  Â  scale: 1,
Â  Â  scrollY: -window.scrollY,
Â  Â  onclone: (clonedDoc) => {
Â  Â  Â  // Apply offset only to the text, not sidelines
Â  Â  Â  const textElements = clonedDoc.querySelectorAll('[data-headline="true"]');
Â  Â  Â  textElements.forEach(el => {
Â  Â  Â  Â  // Move text slightly upward
Â  Â  Â  Â  const currentTop = parseFloat(el.style.top || "0");
Â  Â  Â  Â  el.style.top = (currentTop + textOffset) + "px";
Â  Â  Â  });
Â  Â  }
Â  })
Â  Â  .then((canvas) => {
Â  Â  Â  const link = document.createElement("a");
Â  Â  Â  link.download =
Â  Â  Â  Â  (fileName && fileName.trim() ? fileName.trim() : "social-card") + ".png";
Â  Â  Â  link.href = canvas.toDataURL("image/png");
Â  Â  Â  link.click();
Â  Â  })
Â  Â  .catch((err) => {
Â  Â  Â  console.log("export failed:", err);
Â  Â  });
}, 0);

Â  Â  Â  Â  }

Â  Â  Â  Â  function updateImage(id, updatedProps) {
Â  Â  Â  Â  Â  setImages(current => current.map(im => im.id === id ? { ...im, ...updatedProps } : im));
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateImageFitMode(id, corner) {
Â  Â  Â  Â  Â  setImages(current => current.map(im => {
Â  Â  Â  Â  Â  Â  if (im.id === id) {
Â  Â  Â  Â  Â  Â  Â  const newFitMode = { ...im.fitMode, [corner]: !im.fitMode[corner] };
Â  Â  Â  Â  Â  Â  Â  let newX = im.x;
Â  Â  Â  Â  Â  Â  Â  let newY = im.y;
Â  Â  Â  Â  Â  Â  Â  let newScale = im.scale;
Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  // Count how many checkboxes are selected
Â  Â  Â  Â  Â  Â  Â  const selectedCount = Object.values(newFitMode).filter(Boolean).length;
Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  const isStretchedHorizontally = newFitMode.left && newFitMode.right;
Â  Â  Â  Â  Â  Â  Â  const isStretchedVertically = newFitMode.top && newFitMode.bottom;

Â  Â  Â  Â  Â  Â  Â  if (selectedCount === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  newX = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newY = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newScale = 1;
Â  Â  Â  Â  Â  Â  Â  } else if (isStretchedHorizontally && isStretchedVertically) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Case: All four corners checked - fills the entire canvas (object-fit: cover)
Â  Â  Â  Â  Â  Â  Â  Â  Â  const xScale = width / im.originalWidth;
Â  Â  Â  Â  Â  Â  Â  Â  Â  const yScale = height / im.originalHeight;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newScale = Math.max(xScale, yScale);
Â  Â  Â  Â  Â  Â  Â  Â  Â  const newScaledWidth = im.originalWidth * newScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  const newScaledHeight = im.originalHeight * newScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newX = (width - newScaledWidth) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newY = (height - newScaledHeight) / 2;
Â  Â  Â  Â  Â  Â  Â  } else if (isStretchedHorizontally) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Case: Left and Right selected - stretches horizontally
Â  Â  Â  Â  Â  Â  Â  Â  Â  newScale = width / im.originalWidth;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newX = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Vertical alignment
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (newFitMode.top) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newY = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (newFitMode.bottom) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newScaledHeight = im.originalHeight * newScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newY = height - newScaledHeight;
Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newScaledHeight = im.originalHeight * newScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newY = (height - newScaledHeight) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  } else if (isStretchedVertically) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Case: Top and Bottom selected - stretches vertically
Â  Â  Â  Â  Â  Â  Â  Â  Â  newScale = height / im.originalHeight;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newY = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Horizontal alignment
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (newFitMode.left) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newX = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (newFitMode.right) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newScaledWidth = im.originalWidth * newScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newX = width - newScaledWidth;
Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newScaledWidth = im.originalWidth * newScale;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newX = (width - newScaledWidth) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Case: Single corner or non-opposite sides - simple alignment
Â  Â  Â  Â  Â  Â  Â  Â  Â  newScale = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newX = im.x;
Â  Â  Â  Â  Â  Â  Â  Â  Â  newY = im.y;
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (newFitMode.left) newX = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (newFitMode.right) newX = width - im.originalWidth;
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (newFitMode.top) newY = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (newFitMode.bottom) newY = height - im.originalHeight;
Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  ...im,
Â  Â  Â  Â  Â  Â  Â  Â  fitMode: newFitMode,
Â  Â  Â  Â  Â  Â  Â  Â  x: newX,
Â  Â  Â  Â  Â  Â  Â  Â  y: newY,
Â  Â  Â  Â  Â  Â  Â  Â  scale: newScale,
Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return im;
Â  Â  Â  Â  Â  }));
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function changeImageScale(id, scale) {Â 
Â  Â  Â  Â  Â  Â  const newScale = parseFloat(scale);
Â  Â  Â  Â  Â  Â  if (!isNaN(newScale)) {
Â  Â  Â  Â  Â  Â  Â  Â  setImages((imgs) => imgs.map(im => im.id === id ? { ...im, scale: newScale } : im))Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function changeVignetteScale(scale) {
Â  Â  Â  Â  Â  Â  const newScale = parseFloat(scale);
Â  Â  Â  Â  Â  Â  if (!isNaN(newScale)) {
Â  Â  Â  Â  Â  Â  Â  Â  setVignette(v => ({ ...v, scale: newScale }));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function bringForward(id) { const maxZ = Math.max(...images.map(im => im.zIndex)); setImages((imgs) => imgs.map(im => im.id === id ? { ...im, zIndex: maxZ + 1 } : im)) }
Â  Â  Â  Â  function sendBackward(id) { const minZ = Math.min(...images.map(im => im.zIndex)); setImages((imgs) => imgs.map(im => im.id === id ? { ...im, zIndex: minZ - 1 } : im)) }
Â  Â  Â  Â  function deleteImage(id) { setImages((imgs) => imgs.filter(im => im.id !== id)) }
Â  Â  Â  Â  function selectImage(id) {
Â  Â  Â  Â  Â  setActiveImageId(id);
Â  Â  Â  Â  Â  const maxZ = Math.max(...images.map(im => im.zIndex));
Â  Â  Â  Â  Â  setImages((imgs) => imgs.map(im => im.id === id ? { ...im, zIndex: maxZ + 1 } : im));
Â  Â  Â  Â  }

Â  Â  Â  Â  const backgroundStyle = React.useMemo(() => {
Â  Â  Â  Â  Â  switch (background.type) {
Â  Â  Â  Â  Â  Â  case 'solid':
Â  Â  Â  Â  Â  Â  Â  return { backgroundColor: background.color };
Â  Â  Â  Â  Â  Â  case 'gradient':
Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  backgroundImage: `linear-gradient(${background.gradient.direction}, ${background.gradient.color1}, ${background.gradient.color2})`
Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  case 'image':
Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  backgroundImage: `url('${background.imageSrc}')`,
Â  Â  Â  Â  Â  Â  Â  Â  backgroundSize: 'cover',
Â  Â  Â  Â  Â  Â  Â  Â  backgroundPosition: 'center',
Â  Â  Â  Â  Â  Â  Â  Â  backgroundRepeat: 'no-repeat'
Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  default:
Â  Â  Â  Â  Â  Â  Â  return {};
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, [background]);

Â  Â  Â  Â  function getImageStyle(img) {
Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  left: img.x,
Â  Â  Â  Â  Â  Â  top: img.y,
Â  Â  Â  Â  Â  Â  transform: `scale(${img.scale})`,
Â  Â  Â  Â  Â  Â  transformOrigin: 'top left',
Â  Â  Â  Â  Â  Â  width: img.originalWidth,
Â  Â  Â  Â  Â  Â  height: img.originalHeight,
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  }

Â  Â  Â  Â  const isStretched = (img) => {
Â  Â  Â  Â  Â  return img.fitMode.left && img.fitMode.right || img.fitMode.top && img.fitMode.bottom;
Â  Â  Â  Â  };

Â  Â  Â  Â  Â  // Password submission handler
Â  const handlePasswordSubmit = (e) => {
Â  Â  e.preventDefault();
Â  Â  const password = e.target.elements.password.value;
Â  Â  // âš ï¸ Replace "YOUR_PASSWORD" with your actual password
Â  Â  if (password === "sabah123") {
Â  Â  Â  setIsAuthenticated(true);
Â  Â  } else {
Â  Â  Â  alert("Incorrect password.");
Â  Â  }
Â  };

Â  // Conditional render based on isAuthenticated state
Â  if (!isAuthenticated) {
Â  Â  return (
Â  Â  Â  <div className="flex items-center justify-center min-h-screen bg-gray-200">
Â  Â  Â  Â  <form onSubmit={handlePasswordSubmit} className="p-8 bg-white rounded-lg shadow-md">
Â  Â  Â  Â  Â  <h2 className="text-xl font-bold mb-4">Enter Password to Access</h2>
Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  type="password"
Â  Â  Â  Â  Â  Â  name="password"
Â  Â  Â  Â  Â  Â  placeholder="Enter password"
Â  Â  Â  Â  Â  Â  className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring focus:border-blue-300"
Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  type="submit"
Â  Â  Â  Â  Â  Â  className="mt-4 w-full bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 focus:outline-none focus:ring"
Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Submit
Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  </form>
Â  Â  Â  </div>
Â  Â  );
Â  }

Â  Â  Â  Â  const canDragHeadlines = draggableHeadlines;


Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  <div className="p-4 max-w-7xl mx-auto">
Â  Â  Â  Â  Â  Â  <div className="flex flex-col md:flex-row gap-6">
Â  Â  Â  Â  Â  Â  Â  {/* Controls */}
Â  Â  Â  Â  Â  Â  Â  <div className="w-full md:w-96 space-y-4">
Â  Â  Â  Â  Â  Â  Â  Â  <h2 className="text-xl font-semibold">Controls</h2>

Â  Â  Â  Â  Â  Â  Â  Â  {/* Background Controls */}
Â  Â  Â  Â  Â  Â  Â  Â  <div className="bg-white p-3 rounded shadow">
Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex justify-between items-center cursor-pointer"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => setIsBackgroundCollapsed(!isBackgroundCollapsed)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 className="text-lg font-medium">Background</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{isBackgroundCollapsed ? 'â–¼' : 'â–²'}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  {!isBackgroundCollapsed && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={background.type}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => setBackground({ ...background, type: e.target.value })}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full border p-1 rounded mb-2"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="solid">Solid Color</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="image">Image from File</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="gradient">Gradient</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {background.type === 'solid' && (
                        <div className="flex items-center gap-2">
                            <label className="whitespace-nowrap">Color (Hex):</label>
                            <input
                                type="text"
                                value={background.color.toUpperCase()}
                                onChange={e => setBackground({ ...background, color: e.target.value })}
                                className="w-24 border p-1 rounded font-mono text-xs"
                                placeholder="#RRGGBB"
                            />
                            <input
                                type="color"
                                value={background.color}
                                onChange={e => setBackground({ ...background, color: e.target.value })}
                                className="w-10 h-8 p-0 border rounded"
                            />
                        </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {background.type === 'image' && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="space-y-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm font-medium">Image from File</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex gap-2 items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="file" accept="image/png, image/jpeg" onChange={onBackgroundUpload} className="mt-2" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => setBackground({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...background,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: 'image',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  imageSrc: 'bg.png'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  })}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="bg-blue-500 text-white px-3 py-1 rounded text-sm whitespace-nowrap"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Reset
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}


Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {background.type === 'gradient' && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="space-y-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex items-center gap-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label>Color 1:</label>
                            <input
                                type="text"
                                value={background.gradient.color1.toUpperCase()}
                                onChange={e => setBackground({ ...background, gradient: { ...background.gradient, color1: e.target.value } })}
                                className="w-16 border p-1 rounded font-mono text-xs"
                                placeholder="#RRGGBB"
                            />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="color"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={background.gradient.color1}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => setBackground({ ...background, gradient: { ...background.gradient, color1: e.target.value } })}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-10 h-8 p-0 border rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="ml-4">Color 2:</label>
                            <input
                                type="text"
                                value={background.gradient.color2.toUpperCase()}
                                onChange={e => setBackground({ ...background, gradient: { ...background.gradient, color2: e.target.value } })}
                                className="w-16 border p-1 rounded font-mono text-xs"
                                placeholder="#RRGGBB"
                            />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="color"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={background.gradient.color2}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => setBackground({ ...background, gradient: { ...background.gradient, color2: e.target.value } })}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-10 h-8 p-0 border rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm font-medium">Direction</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={background.gradient.direction}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => setBackground({ ...background, gradient: { ...background.gradient, direction: e.target.value } })}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full border p-1 rounded mt-1"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="to top">To Top</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="to bottom">To Bottom</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="to left">To Left</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="to right">To Right</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="to top left">To Top Left</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="to top right">To Top Right</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="to bottom left">To Bottom Left</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="to bottom right">To Bottom Right</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  {/* Multiple Headlines */}
Â  Â  Â  Â  Â  Â  Â  Â  <div className="bg-white p-3 rounded shadow">
Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 className="text-lg font-medium mb-2">Headlines</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={addHeadline} className="w-full bg-green-500 text-white py-1 rounded mb-2">Add New Headline</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex items-center space-x-2 mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="checkbox"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  id="dragToggle"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  checked={draggableHeadlines}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setDraggableHeadlines(e.target.checked)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label htmlFor="dragToggle" className="text-sm font-medium">Enable drag for headlines</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
                    {/* Word Color Picker for selected text */}
                    <div className="mt-4 p-2 border rounded-md border-purple-300 bg-purple-50">
                        <label className="block text-sm font-bold text-purple-800">Word Color Picker</label>
                        <p className="text-xs text-purple-600 mb-2">1. Select text in the preview. 2. Choose color. 3. Click 'Apply'.</p>
                        <div className="flex gap-2 items-center">
                            <input
                                type="text"
                                value={activeWordColor.toUpperCase()}
                                onChange={e => setActiveWordColor(e.target.value)}
                                className="w-16 border p-1 rounded font-mono text-xs"
                                placeholder="#RRGGBB"
                            />
                            <input
                                type="color"
                                value={activeWordColor}
                                onChange={e => setActiveWordColor(e.target.value)}
                                className="w-10 h-8 p-0 border rounded"
                            />
                            <button 
                                onClick={() => setActiveWordColor('#ff0000')} 
                                className="bg-gray-300 text-xs px-2 py-1 rounded"
                            >Reset</button>
                        </div>
                    </div>
                    {/* End Word Color Picker */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  {headlines.map(headline => (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div key={headline.id} className="border-b last:border-b-0 py-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex justify-between items-center cursor-pointer" onClick={() => setExpandedHeadlineId(expandedHeadlineId === headline.id ? null : headline.id)}>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span className="font-semibold">{partsToText(headline.parts).substring(0, 20)}...</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{expandedHeadlineId === headline.id ? 'â–²' : 'â–¼'}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {expandedHeadlineId === headline.id && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2 space-y-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm font-medium">Text</label>
                            {/* Pass partsToText(headline.parts) to textarea to handle display of combined text */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <textarea dir={headline.direction} value={partsToText(headline.parts)} onChange={e => updateHeadline(headline.id, { text: e.target.value })} className="w-full border p-2 rounded" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-2">Font size</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="number" value={headline.fontSize} onChange={e => updateHeadline(headline.id, { fontSize: parseInt(e.target.value) })} className="w-full border p-1 rounded" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-2">Line height</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="number" step="0.1" value={headline.lineHeight} onChange={e => updateHeadline(headline.id, { lineHeight: parseFloat(e.target.value) })} className="w-full border p-1 rounded" />
                            
                            {/* Main Text Color (resets individual word colors) */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-2">Default Text color (Hex/Picker)</label>
                            <div className="flex gap-2">
                                <input
                                    type="text"
                                    value={headline.textColor.toUpperCase()}
                                    onChange={e => {
                                        // Update the base color and apply it to ALL parts
                                        updateHeadline(headline.id, { 
                                            textColor: e.target.value,
                                            parts: headline.parts.map(p => ({ ...p, color: e.target.value }))
                                        });
                                    }}
                                    className="w-full border p-1 rounded font-mono text-xs"
                                    placeholder="#RRGGBB"
                                />
                                <input
                                    type="color"
                                    value={headline.textColor}
                                    onChange={e => {
                                        // Update the base color and apply it to ALL parts
                                        updateHeadline(headline.id, { 
                                            textColor: e.target.value,
                                            parts: headline.parts.map(p => ({ ...p, color: e.target.value }))
                                        });
                                    }}
                                />
                            </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-3">Font family</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select value={headline.fontFamily} onChange={e => updateHeadline(headline.id, { fontFamily: e.target.value })} className="w-full border p-1 rounded mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="Jameel Noori Nastaleeq">Jameel Noori Nastaleeq</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="JameelNooriNastaliq">Jameel Noori embed</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="Noto Sans Arabic">Noto Sans Arabic</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="Baloo Bhaijaan 2">Baloo Bhaijaan 2</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="Gulzar">Gulzar</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="Montserrat">Montserrat</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="Tahoma">Tahoma</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="Arial">Arial</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-3">Text direction</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select value={headline.direction} onChange={e => updateHeadline(headline.id, { direction: e.target.value })} className="w-full border p-1 rounded mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="ltr">Left to Right</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="rtl">Right to Left</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-3">Text align</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select value={headline.textAlign} onChange={e => updateHeadline(headline.id, { textAlign: e.target.value })} className="w-full border p-1 rounded mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="left">Left</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="right">Right</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="center">Center</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="justify">Justify</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-3">X position</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="number" value={headline.textPos.x} onChange={e => updateHeadline(headline.id, { textPos: { ...headline.textPos, x: parseFloat(e.target.value) } })} className="w-full border p-1 rounded" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-3">Y position</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="number" value={headline.textPos.y} onChange={e => updateHeadline(headline.id, { textPos: { ...headline.textPos, y: parseFloat(e.target.value) } })} className="w-full border p-1 rounded" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm mt-3">Headline width</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <inputÂ 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="number"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={headline.width || 800}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => updateHeadline(headline.id, { width: parseInt(e.target.value) })}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full border p-1 rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {/* Shadow Controls */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-4">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="checkbox" checked={headline.shadow.enabled} onChange={e => updateHeadline(headline.id, { shadow: { ...headline.shadow, enabled: e.target.checked } })} />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span className="ml-2">Enable shadow</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {headline.shadow.enabled && <div className="mt-2 grid grid-cols-2 gap-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="text-sm">OffsetX<input type="number" value={headline.shadow.offsetX} onChange={e => updateHeadline(headline.id, { shadow: { ...headline.shadow, offsetX: parseInt(e.target.value) } })} className="w-full border p-1 rounded" /></label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="text-sm">OffsetY<input type="number" value={headline.shadow.offsetY} onChange={e => updateHeadline(headline.id, { shadow: { ...headline.shadow, offsetY: parseInt(e.target.value) } })} className="w-full border p-1 rounded" /></label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="text-sm">Blur<input type="number" value={headline.shadow.blur} onChange={e => updateHeadline(headline.id, { shadow: { ...headline.shadow, blur: parseInt(e.target.value) } })} className="w-full border p-1 rounded" /></label>
                                <label className="text-sm">Color</label>
                                <div className="flex gap-1 items-center">
                                    <input
                                        type="text"
                                        value={headline.shadow.color}
                                        onChange={e => updateHeadline(headline.id, { shadow: { ...headline.shadow, color: e.target.value } })}
                                        className="flex-1 border p-1 rounded font-mono text-xs"
                                        placeholder="#RRGGBB or rgba"
                                    />
                                    <input
                                        type="color"
                                        value={headline.shadow.color.startsWith('#') ? headline.shadow.color : '#000000'}
                                        onChange={e => updateHeadline(headline.id, { shadow: { ...headline.shadow, color: e.target.value } })}
                                        className="w-8 h-8 p-0 border rounded"
                                    />
                                </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {/* Stroke Controls */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-4">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="checkbox" checked={headline.stroke.enabled} onChange={e => updateHeadline(headline.id, { stroke: { ...headline.stroke, enabled: e.target.checked } })} />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span className="ml-2">Enable stroke</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {headline.stroke.enabled && <div className="mt-2 grid grid-cols-2 gap-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="text-sm">Width<input type="number" value={headline.stroke.width} onChange={e => updateHeadline(headline.id, { stroke: { ...headline.stroke, width: parseInt(e.target.value) } })} className="w-full border p-1 rounded" /></label>
                                <label className="text-sm">Color</label>
                                <div className="flex gap-1 items-center">
                                    <input
                                        type="text"
                                        value={headline.stroke.color.toUpperCase()}
                                        onChange={e => updateHeadline(headline.id, { stroke: { ...headline.stroke, color: e.target.value } })}
                                        className="flex-1 border p-1 rounded font-mono text-xs"
                                        placeholder="#RRGGBB"
                                    />
                                    <input
                                        type="color"
                                        value={headline.stroke.color}
                                        onChange={e => updateHeadline(headline.id, { stroke: { ...headline.stroke, color: e.target.value } })}
                                        className="w-8 h-8 p-0 border rounded"
                                    />
                                </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {/* Sideline Controls */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-4">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="checkbox" checked={headline.sideline.show} onChange={e => updateHeadline(headline.id, { sideline: { ...headline.sideline, show: e.target.checked } })} />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span className="ml-2">Show sideline</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {headline.sideline.show && <>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm">Width<input type="number" value={headline.sideline.width} onChange={e => updateHeadline(headline.id, { sideline: { ...headline.sideline, width: parseInt(e.target.value) } })} className="w-full border p-1 rounded" /></label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm">Gap<input type="number" value={headline.sideline.gap} onChange={e => updateHeadline(headline.id, { sideline: { ...headline.sideline, gap: parseInt(e.target.value) } })} className="w-full border p-1 rounded" /></label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm">Height<input type="number" value={headline.sideline.height ?? ""}
Â  Â  onChange={e => {
Â  Â  Â  const raw = e.target.value;
Â  Â  Â  if (raw === "") {
Â  Â  Â  Â  // user cleared the field â€” keep height null but DO NOT enable autosize here.
Â  Â  Â  Â  updateHeadline(headline.id, {
Â  Â  Â  Â  Â  sideline: { ...headline.sideline, height: null, autoHeight: true }
Â  Â  Â  Â  });
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  const parsed = parseInt(raw, 10);
Â  Â  Â  const final = Number.isNaN(parsed) ? null : parsed;
Â  Â  Â  // When user provides a concrete height, disable autoHeight so autosizer stops overwriting it.
Â  Â  Â  updateHeadline(headline.id, {
Â  Â  Â  Â  sideline: { ...headline.sideline, height: final, autoHeight: false }
Â  Â  Â  });
Â  Â  }}
Â  Â  onBlur={e => {
Â  Â  Â  // optional: if empty after blur, set a default automatic behavior
Â  Â  Â  if (e.target.value === "") {
Â  Â  Â  Â  updateHeadline(headline.id, {
Â  Â  Â  Â  Â  sideline: { ...headline.sideline, height: null, autoHeight: true }
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  }}
Â  Â  className="w-full border p-1 rounded" /></label>
                                <label className="block text-sm">Color</label>
                                <div className="flex gap-1 items-center">
                                    <input
                                        type="text"
                                        value={headline.sideline.color.toUpperCase()}
                                        onChange={e => updateHeadline(headline.id, { sideline: { ...headline.sideline, color: e.target.value } })}
                                        className="flex-1 border p-1 rounded font-mono text-xs"
                                        placeholder="#RRGGBB"
                                    />
                                    <input
                                        type="color"
                                        value={headline.sideline.color}
                                        onChange={e => updateHeadline(headline.id, { sideline: { ...headline.sideline, color: e.target.value } })}
                                        className="w-8 h-8 p-0 border rounded"
                                    />
                                </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm">Transparency<input type="range" min="0" max="1" step="0.05" value={headline.sideline.opacity} onChange={e => updateHeadline(headline.id, { sideline: { ...headline.sideline, opacity: parseFloat(e.target.value) } })} className="w-full" /></label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm">Vertical offset<input type="number" value={headline.sidelineOffset} onChange={e => updateHeadline(headline.id, { sidelineOffset: parseInt(e.target.value) })} className="w-full border p-1 rounded mt-1" /></label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </>}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => deleteHeadline(headline.id)} className="w-full bg-red-500 text-white py-1 rounded mt-2">Delete</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  ))}
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  {/* Images Controls */}
Â  Â  Â  Â  Â  Â  Â  Â  <div className="bg-white p-3 rounded shadow">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex justify-between items-center cursor-pointer"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => setIsImagesCollapsed(!isImagesCollapsed)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 className="text-lg font-medium">Images</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{isImagesCollapsed ? 'â–¼' : 'â–²'}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {!isImagesCollapsed && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm font-medium">Upload images</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="file" accept="image/*" multiple onChange={onImageUpload} className="mt-2" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {images.map(img => (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div key={img.id} className={`bg-white p-3 rounded shadow space-y-1 ${activeImageId === img.id ? 'border-2 border-blue-500' : ''}`}>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex justify-between items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span className="text-sm">Image {img.id}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => deleteImage(img.id)} className="text-red-500 text-sm">Delete</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm">Zoom</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex items-center gap-2 mt-1">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => changeImageScale(img.id, img.scale - 0.01)} className="bg-gray-200 w-8 h-8 rounded-full flex items-center justify-center text-lg font-bold">-</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="number"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  min="0.1"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  max="3"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  step="0.01"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={img.scale}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => changeImageScale(img.id, e.target.value)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full border p-1 rounded text-center"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => changeImageScale(img.id, img.scale + 0.01)} className="bg-gray-200 w-8 h-8 rounded-full flex items-center justify-center text-lg font-bold">+</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex gap-2 mt-1">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => bringForward(img.id)} className="bg-gray-200 px-2 py-1 rounded text-sm">Bring Forward</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => sendBackward(img.id)} className="bg-gray-200 px-2 py-1 rounded text-sm">Send Backward</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {/* New Fit controls */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-4">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span className="ml-2 text-sm font-semibold">Align Image</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="space-y-2 mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex items-center justify-around mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center gap-1 text-xs">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="checkbox" checked={img.fitMode.top} onChange={() => updateImageFitMode(img.id, 'top')} /> Top
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center gap-1 text-xs">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="checkbox" checked={img.fitMode.right} onChange={() => updateImageFitMode(img.id, 'right')} /> Right
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center gap-1 text-xs">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="checkbox" checked={img.fitMode.bottom} onChange={() => updateImageFitMode(img.id, 'bottom')} /> Bottom
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center gap-1 text-xs">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="checkbox" checked={img.fitMode.left} onChange={() => updateImageFitMode(img.id, 'left')} /> Left
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>


Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ))}

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex items-center gap-2 mb-4">
                            <label className="text-sm whitespace-nowrap">Border color (Hex):</label>
                            <input
                                type="text"
                                value={globalBorderColor.toUpperCase()}
                                onChange={(e) => setGlobalBorderColor(e.target.value)}
                                className="w-16 border p-1 rounded font-mono text-xs"
                                placeholder="#RRGGBB"
                            />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="color"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={globalBorderColor}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setGlobalBorderColor(e.target.value)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-10 h-8 p-0 border rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="text-sm ml-2">Size:</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="number"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={globalBorderSize}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setGlobalBorderSize(Number(e.target.value))}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-16 px-2 py-1 border rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  min="0"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {activeImageId && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex items-center gap-2 mb-4">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="text-sm">Show border</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="checkbox"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  checked={
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  images.find((img) => img.id === activeImageId)?.borderEnabled ?? false
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) =>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setImages((prev) =>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  prev.map((img) =>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  img.id === activeImageId
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ? { ...img, borderEnabled: e.target.checked }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  : img
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  {/* Vignette Controls */}
Â  Â  Â  Â  Â  Â  Â  Â  <div className="bg-white p-3 rounded shadow">
Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex justify-between items-center cursor-pointer"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => setIsVignetteCollapsed(!isVignetteCollapsed)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 className="text-lg font-medium">Finalize</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{isVignetteCollapsed ? 'â–¼' : 'â–²'}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  {!isVignetteCollapsed && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2 space-y-1">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â <label className="flex items-center">
Â  <input
Â  Â  type="checkbox"
Â  Â  checked={vignette.show}
Â  Â  onChange={e => {
Â  Â  Â  const checked = e.target.checked;

Â  Â  Â  // when turning ON vignette, set it to same Base64 as background
Â  Â  Â  if (checked && backgroundStyle?.backgroundImage) {
Â  Â  Â  Â  const base64Src = backgroundStyle.backgroundImage
Â  Â  Â  Â  Â  .replace(/^url\(["']?/, "")
Â  Â  Â  Â  Â  .replace(/["']?\)$/, "");
Â  Â  Â  Â  setVignette({
Â  Â  Â  Â  Â  ...vignette,
Â  Â  Â  Â  Â  show: true,
Â  Â  Â  Â  Â  src: base64Src,
Â  Â  Â  Â  Â  locked: true, // auto-lock when using base64
Â  Â  Â  Â  Â  x: 0,
Â  Â  Â  Â  Â  y: 0,
Â  Â  Â  Â  Â  scale: 1,
Â  Â  Â  Â  });
Â  Â  Â  } else {
Â  Â  Â  Â  // turning OFF vignette
Â  Â  Â  Â  setVignette({ ...vignette, show: false, locked: false });
Â  Â  Â  }
Â  Â  }}
Â  />
Â  <span className="ml-2">Finalize SM Card</span>
</label>

{/* Lock position option */}
{vignette.show && (
Â  <label className="flex items-center mt-1">
Â  Â  <input
Â  Â  Â  type="checkbox"
Â  Â  Â  checked={vignette.locked}
Â  Â  Â  disabled={!!vignette.src} // auto-locked if using base64
Â  Â  Â  onChange={e =>
Â  Â  Â  Â  setVignette({ ...vignette, locked: e.target.checked })
Â  Â  Â  }
Â  Â  />
Â  Â  <span className="ml-2">
Â  Â  Â  Lock Position {vignette.src ? "(auto-locked)" : ""}
Â  Â  </span>
Â  </label>
)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {vignette.show && <>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm">Zoom</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex items-center gap-2 mt-1">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => changeVignetteScale(vignette.scale - 0.01)} className="bg-gray-200 w-8 h-8 rounded-full flex items-center justify-center text-lg font-bold">-</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="number"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  min="0.1"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  max="3"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  step="0.01"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={vignette.scale}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => changeVignetteScale(e.target.value)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full border p-1 rounded text-center"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => changeVignetteScale(vignette.scale + 0.01)} className="bg-gray-200 w-8 h-8 rounded-full flex items-center justify-center text-lg font-bold">+</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </>}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  {/* Logo Controls */}
Â  Â  Â  Â  Â  Â  Â  Â  <div className="bg-white p-3 rounded shadow">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex justify-between items-center cursor-pointer"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => setIsLogoCollapsed(!isLogoCollapsed)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 className="text-lg font-medium">Logo</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{isLogoCollapsed ? 'â–¼' : 'â–²'}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {!isLogoCollapsed && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="checkbox" checked={logo.show} onChange={e => setLogo({ ...logo, show: e.target.checked })} />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span className="ml-2">Show Logo</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {logo.show &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select value={logo.position} onChange={e => setLogo({ ...logo, position: e.target.value })} className="w-full border p-1 rounded mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="top-left">Top Left</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="top-right">Top Right</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="top-center">Top Center</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="bottom-left">Bottom Left</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="bottom-right">Bottom Right</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  {/* Canvas Controls */}
Â  Â  Â  Â  Â  Â  Â  Â  <div className="bg-white p-3 rounded shadow">
Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex justify-between items-center cursor-pointer"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => setIsCanvasCollapsed(!isCanvasCollapsed)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 className="text-lg font-medium">Canvas</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{isCanvasCollapsed ? 'â–¼' : 'â–²'}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  {!isCanvasCollapsed && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm font-medium">Canvas size</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex gap-2 mt-2 flex-wrap">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => { setWidth(1080); setHeight(1080); }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="bg-gray-200 px-3 py-1 rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Instagram Square
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => { setWidth(1080); setHeight(1920); }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="bg-gray-200 px-3 py-1 rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Instagram Story
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => { setWidth(1200); setHeight(720); }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="bg-gray-200 px-3 py-1 rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  YouTube
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  {/* Presets */}
Â  Â  Â  Â  Â  Â  Â  Â  <div className="bg-white p-3 rounded shadow">
Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex justify-between items-center cursor-pointer"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => setIsPresetsCollapsed(!isPresetsCollapsed)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 className="text-lg font-medium">Presets</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{isPresetsCollapsed ? 'â–¼' : 'â–²'}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  {!isPresetsCollapsed && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select id="presetSelect" className="w-full border p-1 rounded mb-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="">Select a preset</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {Object.keys(presets).map(key => (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option key={key} value={key}>{key}</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ))}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex space-x-2 mb-3">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const select = document.getElementById("presetSelect");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (select && select.value) loadPreset(select.value);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex-1 bg-purple-500 text-white py-1 rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Load
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const select = document.getElementById("presetSelect");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (select && select.value) deletePreset(select.value);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex-1 bg-red-600 text-white py-1 rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Delete
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  id="presetName"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="text"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  placeholder="Preset name"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full border p-1 rounded mb-2"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const input = document.getElementById("presetName");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (input && input.value) savePreset(input.value);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full bg-green-600 text-white py-1 rounded mb-2"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Save Current Layout as Preset
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={resetPresets}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full bg-gray-600 text-white py-1 rounded mb-2"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Reset to Default Presets
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={exportPresets}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full bg-blue-600 text-white py-1 rounded mb-2"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Export All Presets (Copy JSON)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={importPresets}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full bg-yellow-500 text-white py-1 rounded"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Import Presets (Paste JSON)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  {/* File Name & Export */}
Â  Â  Â  Â  Â  Â  Â  Â  <div className="bg-white p-3 rounded shadow">
Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="flex justify-between items-center cursor-pointer"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onClick={() => setIsFileNameCollapsed(!isFileNameCollapsed)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 className="text-lg font-medium">File & Export</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{isFileNameCollapsed ? 'â–¼' : 'â–²'}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  {!isFileNameCollapsed && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mt-2 space-y-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm">File name</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="text" value={fileName} onChange={e => setFileName(e.target.value)} className="w-full border p-1 rounded" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={exportAsImage} className="w-full bg-blue-600 text-white py-2 rounded mt-2">Export PNG</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  {/* Preview */}
Â  Â  Â  Â  Â  Â  Â  <div className="flex-1 max-w-full mt-6 md:mt-0">
Â  Â  Â  Â  Â  Â  Â  Â  <div className="sticky top-4">
Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="mb-2">Preview (Output size: {width}Ã—{height})</div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  <div ref={containerRef} className="relative mx-auto bg-black overflow-hidden" style={{ width, height, ...backgroundStyle }}>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {/* Images */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {images.sort((a, b) => a.zIndex - b.zIndex).map(img => (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  key={img.id}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onMouseDown={e => startDragImage(e, img.id)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onTouchStart={e => startDragImage(e, img.id)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="absolute"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  zIndex: img.zIndex,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cursor: "grab",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...getImageStyle(img),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <img
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  src={img.src}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alt="Uploaded Image"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  display: "block",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  width: "100%",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  height: "100%",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  objectFit: isStretched(img) ? 'cover' : 'none',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  border: img.borderEnabled
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ? `${globalBorderSize}px solid ${globalBorderColor}`
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  : "none",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ))}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {/* Vignette */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {vignette.show && (
Â  <img
Â  Â  src={vignette.src || "Vignette.png"}
Â  Â  alt="Vignette"
Â  Â  onMouseDown={!vignette.locked ? startDragVignette : undefined}
Â  Â  onTouchStart={!vignette.locked ? startDragVignette : undefined}
Â  Â  style={{
Â  Â  Â  position: "absolute",
Â  Â  Â  left: vignette.x,
Â  Â  Â  top: vignette.y,
Â  Â  Â  transform: `scale(${vignette.scale})`,
Â  Â  Â  cursor: vignette.locked ? "default" : "grab",
Â  Â  Â  width: "100%",
Â  Â  Â  height: "100%",
Â  Â  Â  zIndex: 100,
Â  Â  }}
Â  />
)}


Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {/* Logo */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {logo.show && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <img
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  src="logo.png"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alt="Logo"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  position: "absolute",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  width: 120,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  height: 60,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...(logo.position === "top-left" ? { left: 30, top: 150 } : {}),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...(logo.position === "top-right" ? { right: 30, top: 150 } : {}),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...(logo.position === "top-center" ? { right: 500, top: 50 } : {}),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...(logo.position === "bottom-left" ? { left: 30, bottom: 150 } : {}),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...(logo.position === "bottom-right" ? { right: 30, bottom: 150 } : {}),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  zIndex: 300,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {/* Multiple Headlines (using new EditableHeadline component) */}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {headlines.map(headline => (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <React.Fragment key={headline.id}>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {headline.sideline.show && (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="sideline-clone"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  position: "absolute",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  left: headline.direction === "ltr" ? headline.sideline.gap : "auto",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  right: headline.direction === "rtl" ? headline.sideline.gap : "auto",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  top: headline.textPos.y + (headline.sidelineOffset || 0),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  height: headline.sideline.height || 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  width: headline.sideline.width,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  background: headline.sideline.color,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opacity: headline.sideline.opacity,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pointerEvents: "none",
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  zIndex: 200,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
                        
                        <EditableHeadline
                            headline={{ ...headline, draggableHeadlines, startDragText }}
                            updateHeadline={updateHeadline}
                            headlineRefs={headlineRefs}
                            activeColor={activeWordColor}
                            onColorApply={() => setActiveWordColor('#ff0000')}
                        />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </React.Fragment>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ))}
Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  );
Â  Â  Â  }

Â  Â  Â  ReactDOM.createRoot(document.getElementById("root")).render(<SocialCardGenerator />);
Â  Â  </script>
Â  </body>
</html>
