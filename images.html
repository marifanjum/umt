<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Image Manipulation â€” Collage Extension</title>
<style>
  body { margin: 8px; font-family: Arial, sans-serif; }
  .controls-row { margin-bottom: 10px; display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  button { padding: 10px 16px; font-size: 15px; cursor: pointer; }
  label { font-size: 15px; }
  .small { font-size: 13px; }
  #canvasContainer { position: relative; width: 1200px; height: 720px; border: 2px solid black; overflow: hidden; margin-bottom: 12px; touch-action: none; }
  #canvas { position: absolute; top: 0; left: 0; cursor: move; touch-action: none; }
  input[type="text"] { padding: 6px; font-size: 15px; width: 260px; }
  #imageInputLabel {
    display: inline-block;
    padding: 12px 22px;
    font-size: 18px;
    background-color: #2d89ef;
    color: white;
    border-radius: 8px;
    cursor: pointer;
  }
  #imageInput { display: none; }
  .slot-load { padding:8px 12px; font-size:14px; background:#eee; border-radius:6px; cursor:pointer; }
  .slot-container { display:inline-flex; gap:8px; align-items:center; }
  .slot-overlay {
    position: absolute;
    border: 3px dashed #1e90ff;
    pointer-events: none;
    box-sizing: border-box;
    display: none;
  }
  .note { font-size: 13px; color: #555; }
  select, input[type="color"] { font-size: 14px; padding:4px; }
</style>
</head>
<body>

<h2>Image Resize and Collage</h2>

<div class="controls-row">
  <label><input type="radio" name="mode" value="single" checked> Single Image Mode</label>
  <label><input type="radio" name="mode" value="collage"> Collage Mode</label>

  <span id="singleControls" style="display:inline-flex; gap:12px; align-items:center;">
    <label id="imageInputLabel">ðŸ“‚ Load Image for Edit</label>
    <input type="file" id="imageInput" accept="image/*">
    <span class="note">Paste supported (Ctrl/Cmd+V)</span>
  </span>

  <span id="collageControls" style="display:none; gap:12px; align-items:center;">
    <label>Images:
      <select id="collageCount">
        <option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>8</option>
      </select>
    </label>

    <label>Layout:
        <select id="collageLayout" class="small">
          <option value="grid-equal">Equal Grid</option>
          <option value="row">Row</option>
          <option value="column">Column</option>
          <option value="grid-1big">1 Big + Sidebar</option>
        </select>
    </label>
    <button id="generateCollageSlots">Generate Slots</button>
  </span>
</div>

<div id="canvasContainer">
  <canvas id="canvas" width="1200" height="720"></canvas>
  <div id="slotOverlay" class="slot-overlay"></div>
</div>

<div class="controls-row">
  <button id="stretchButton">Fit Short Side</button>
  <button id="fitLongestSideButton">Fit Longest Side</button>
  <button id="centerButton">Center Image</button>
  <button id="fillCanvasButton">Auto Fill</button>
</div>

<div class="controls-row">
  <label><input type="checkbox" id="toggleBorder"> Double Border</label>
  <label><input type="checkbox" id="toggleBg"> Background Image</label>
  <input type="file" id="bgImageInput" accept="image/*">
  <label><input type="checkbox" id="toggleGradient"> Gradient</label>
</div>

<div class="controls-row">
  <label><input type="checkbox" id="toggleLogo"> Credit Label</label>
  <input type="text" id="logoTextInput" placeholder="Text Label">
</div>

<div id="collageSlotLoaders" class="controls-row" style="display:none;"></div>

<div class="controls-row">
  <button id="downloadCanvasButton">Download Final Image</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const modeRadios = document.getElementsByName('mode');
const singleControls = document.getElementById('singleControls');
const collageControls = document.getElementById('collageControls');
const imageInput = document.getElementById('imageInput');
const bgImageInput = document.getElementById('bgImageInput');
const collageCount = document.getElementById('collageCount');
const collageLayout = document.getElementById('collageLayout');
const collageSlotLoaders = document.getElementById('collageSlotLoaders');
const slotOverlay = document.getElementById('slotOverlay');

// State
let mode = 'single';
let image = null;
let offsetX = 0, offsetY = 0, scale = 1;
let forceStretchMode = false;
const MIN_SCALE = 0.05, MAX_SCALE = 20;

let isDragging = false, dragStartX = 0, dragStartY = 0;
let isPinching = false, initialPinchDistance = 0, lastScale = 1;

let collageSlots = [];
let activeSlotIndex = -1;
let isDraggingSlot = false;
let slotDragStart = {x: 0, y: 0};
let collagePinching = false, collageInitialDist = 0, collageLastScale = 1;

let bgImage = new Image();

function toCanvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (clientX - rect.left) * (canvas.width / rect.width),
    y: (clientY - rect.top) * (canvas.height / rect.height)
  };
}

// --- Mode switching ---
function updateModeUI() {
  if (mode === 'single') {
    singleControls.style.display = 'inline-flex';
    collageControls.style.display = 'none';
    collageSlotLoaders.style.display = 'none';
    slotOverlay.style.display = 'none';
  } else {
    singleControls.style.display = 'none';
    collageControls.style.display = 'inline-flex';
    collageSlotLoaders.style.display = 'flex';
  }
  drawAll();
}

for (const r of modeRadios) {
  r.addEventListener('change', () => { if (r.checked) { mode = r.value; updateModeUI(); } });
}

// --- Image Loading ---
imageInput.addEventListener('change', e => {
  const f = e.target.files[0];
  if (f) {
    const reader = new FileReader();
    reader.onload = ev => {
      image = new Image();
      image.onload = () => { fitSingleImageToCanvas(); };
      image.src = ev.target.result;
    };
    reader.readAsDataURL(f);
  }
});

window.addEventListener('paste', e => {
  const items = e.clipboardData.items;
  for (let i = 0; i < items.length; i++) {
    if (items[i].type.indexOf('image') !== -1) {
      const file = items[i].getAsFile();
      if (mode === 'collage' && activeSlotIndex >= 0) loadImageToSlot(activeSlotIndex, file);
      else if (mode === 'single') {
        const reader = new FileReader();
        reader.onload = ev => {
          image = new Image();
          image.onload = () => fitSingleImageToCanvas();
          image.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      }
    }
  }
});

// --- Collage Logic ---
document.getElementById('generateCollageSlots').addEventListener('click', () => {
  const count = parseInt(collageCount.value, 10);
  collageSlots = [];
  collageSlotLoaders.innerHTML = '';
  activeSlotIndex = -1;
  
  for (let i = 0; i < count; i++) {
    const wrapper = document.createElement('div');
    wrapper.className = 'slot-container';
    const label = document.createElement('label');
    label.className = 'slot-load';
    label.textContent = `Slot ${i+1}`;
    
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.style.display = 'none';
    fileInput.addEventListener('change', (e) => { if(e.target.files[0]) loadImageToSlot(i, e.target.files[0]); });
    
    label.addEventListener('click', () => fileInput.click());
    wrapper.addEventListener('click', () => setActiveSlot(i));
    wrapper.appendChild(label);
    collageSlotLoaders.appendChild(wrapper);
    
    collageSlots.push({ img: null, rect: {x:0,y:0,w:0,h:0}, offsetX: 0, offsetY: 0, scale: 1 });
  }
  computeCollageLayout();
  drawAll();
});

function loadImageToSlot(index, file) {
  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      const r = collageSlots[index].rect;
      const s = Math.min(r.w / img.width, r.h / img.height);
      collageSlots[index].img = img;
      collageSlots[index].scale = s;
      collageSlots[index].offsetX = r.x + (r.w - img.width * s) / 2;
      collageSlots[index].offsetY = r.y + (r.h - img.height * s) / 2;
      drawAll();
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  setActiveSlot(index);
}

function setActiveSlot(index) {
  activeSlotIndex = index;
  const slot = collageSlots[index];
  if (!slot) { slotOverlay.style.display = 'none'; return; }
  const r = slot.rect;
  slotOverlay.style.left = r.x + 'px';
  slotOverlay.style.top = r.y + 'px';
  slotOverlay.style.width = r.w + 'px';
  slotOverlay.style.height = r.h + 'px';
  slotOverlay.style.display = 'block';
}

function computeCollageLayout() {
  const count = collageSlots.length;
  const layout = collageLayout.value;
  const W = canvas.width, H = canvas.height;

  if (layout === 'grid-equal') {
    const cols = Math.ceil(Math.sqrt(count));
    const rows = Math.ceil(count / cols);
    const cellW = W / cols, cellH = H / rows;
    collageSlots.forEach((s, i) => {
      s.rect = { x: (i % cols) * cellW, y: Math.floor(i / cols) * cellH, w: cellW, h: cellH };
    });
  } else if (layout === 'row') {
    const w = W / count;
    collageSlots.forEach((s, i) => s.rect = { x: i * w, y: 0, w: w, h: H });
  } else if (layout === 'column') {
    const h = H / count;
    collageSlots.forEach((s, i) => s.rect = { x: 0, y: i * h, w: W, h: h });
  }
}

// --- Unified Interaction Handlers (FIXED) ---

canvas.addEventListener('mousedown', (e) => {
  const p = toCanvasCoords(e.clientX, e.clientY);
  if (mode === 'collage') {
    // Check if clicking into a new slot
    for (let i = collageSlots.length - 1; i >= 0; i--) {
      const r = collageSlots[i].rect;
      if (p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h) {
        setActiveSlot(i);
        break;
      }
    }
    if (activeSlotIndex >= 0) {
      isDraggingSlot = true;
      slotDragStart = { x: p.x - collageSlots[activeSlotIndex].offsetX, y: p.y - collageSlots[activeSlotIndex].offsetY };
    }
  } else {
    if (!image || forceStretchMode) return;
    isDragging = true;
    dragStartX = p.x - offsetX;
    dragStartY = p.y - offsetY;
    canvas.style.cursor = 'grabbing';
  }
});

window.addEventListener('mousemove', (e) => {
  const p = toCanvasCoords(e.clientX, e.clientY);
  if (mode === 'collage' && isDraggingSlot && activeSlotIndex >= 0) {
    collageSlots[activeSlotIndex].offsetX = p.x - slotDragStart.x;
    collageSlots[activeSlotIndex].offsetY = p.y - slotDragStart.y;
    drawAll();
  } else if (mode === 'single' && isDragging) {
    offsetX = p.x - dragStartX;
    offsetY = p.y - dragStartY;
    drawAll();
  }
});

window.addEventListener('mouseup', () => {
  isDragging = false;
  isDraggingSlot = false;
  canvas.style.cursor = 'move';
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const p = toCanvasCoords(e.clientX, e.clientY);
  const zoom = e.deltaY < 0 ? 1.1 : 0.9;
  
  if (mode === 'collage' && activeSlotIndex >= 0) {
    const s = collageSlots[activeSlotIndex];
    const oldScale = s.scale;
    s.scale = Math.max(0.1, s.scale * zoom);
    s.offsetX = p.x - (p.x - s.offsetX) * (s.scale / oldScale);
    s.offsetY = p.y - (p.y - s.offsetY) * (s.scale / oldScale);
  } else if (mode === 'single' && image) {
    const oldScale = scale;
    scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoom));
    offsetX = p.x - (p.x - offsetX) * (scale / oldScale);
    offsetY = p.y - (p.y - offsetY) * (scale / oldScale);
  }
  drawAll();
}, { passive: false });

// --- Touch Handlers (Unified) ---
canvas.addEventListener('touchstart', e => {
    const p = toCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    if (mode === 'collage') {
        for (let i = collageSlots.length - 1; i >= 0; i--) {
            const r = collageSlots[i].rect;
            if (p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h) { setActiveSlot(i); break; }
        }
        if (activeSlotIndex >= 0) {
            if (e.touches.length === 1) {
                isDraggingSlot = true;
                slotDragStart = { x: p.x - collageSlots[activeSlotIndex].offsetX, y: p.y - collageSlots[activeSlotIndex].offsetY };
            } else {
                collagePinching = true;
                collageInitialDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                collageLastScale = collageSlots[activeSlotIndex].scale;
            }
        }
    } else {
        if (e.touches.length === 1) {
            isDragging = true;
            dragStartX = p.x - offsetX; dragStartY = p.y - offsetY;
        } else {
            isPinching = true;
            initialPinchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            lastScale = scale;
        }
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (mode === 'collage' && activeSlotIndex >= 0) {
        if (e.touches.length === 1 && isDraggingSlot) {
            const p = toCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
            collageSlots[activeSlotIndex].offsetX = p.x - slotDragStart.x;
            collageSlots[activeSlotIndex].offsetY = p.y - slotDragStart.y;
        } else if (e.touches.length === 2 && collagePinching) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            collageSlots[activeSlotIndex].scale = collageLastScale * (dist / collageInitialDist);
        }
    } else if (mode === 'single' && image) {
        if (e.touches.length === 1 && isDragging) {
            const p = toCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
            offsetX = p.x - dragStartX; offsetY = p.y - dragStartY;
        } else if (e.touches.length === 2 && isPinching) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            scale = lastScale * (dist / initialPinchDistance);
        }
    }
    drawAll();
}, { passive: false });

canvas.addEventListener('touchend', () => { isDragging = false; isDraggingSlot = false; isPinching = false; collagePinching = false; });

// --- Drawing & Helpers ---
function fitSingleImageToCanvas() {
  if (!image) return;
  scale = Math.min(canvas.width / image.width, canvas.height / image.height);
  offsetX = (canvas.width - image.width * scale) / 2;
  offsetY = (canvas.height - image.height * scale) / 2;
  drawAll();
}

function drawAll() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (mode === 'single' && image) {
    ctx.drawImage(image, offsetX, offsetY, image.width * scale, image.height * scale);
  } else if (mode === 'collage') {
    collageSlots.forEach(s => {
      ctx.save();
      ctx.beginPath(); ctx.rect(s.rect.x, s.rect.y, s.rect.w, s.rect.h); ctx.clip();
      if (s.img) {
        ctx.drawImage(s.img, s.offsetX, s.offsetY, s.img.width * s.scale, s.img.height * s.scale);
      } else {
        ctx.fillStyle = "#f0f0f0"; ctx.fillRect(s.rect.x, s.rect.y, s.rect.w, s.rect.h);
        ctx.strokeStyle = "#ccc"; ctx.strokeRect(s.rect.x, s.rect.y, s.rect.w, s.rect.h);
      }
      ctx.restore();
    });
  }

  if (document.getElementById('toggleBorder').checked) {
    ctx.strokeStyle = "grey"; ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
    ctx.strokeRect(15, 15, canvas.width - 30, canvas.height - 30);
  }
}

document.getElementById('downloadCanvasButton').addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = 'collage_export.jpg';
  link.href = canvas.toDataURL('image/jpeg', 0.9);
  link.click();
});

// Init
updateModeUI();
</script>
</body>
</html>
